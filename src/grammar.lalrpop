use crate::tokens::{Token, LexicalError};
use crate::ast;
use crate::types::Type;

grammar;

pub Script: Vec<ast::Stmt> = {
  <gstmts:GlobalStmt*> => gstmts
}

pub GlobalStmt: ast::Stmt = {
  StmtMainDef,
  StmtGlobalVarDef,
  StmtFnDef,
}

pub Stmt: ast::Stmt = {
  StmtVarDef,
  StmtVarAssign,
  StmtFixedArrayDef,
  StmtPrint,
  StmtFnCall,
  StmtReturn,
  StmtIf,
  StmtWhile,
  StmtFor,
}

pub StmtMainDef: ast::Stmt = {
  "fn" "main" "{" <body:Stmt*> "}" => {
    ast::Stmt::MainDef {
        body,
    }
  },
}

StmtIf: ast::Stmt = {
    "if" <cond:Expr> "{" <then_body:Stmt*> "}" => ast::Stmt::If {
        cond,
        then_body,
        else_body: None,
    },
    "if" <cond:Expr> "{" <then_body:Stmt*> "}" "else" "{" <else_body:Stmt*> "}" => ast::Stmt::If {
        cond,
        then_body,
        else_body: Some(else_body),
    },
};

pub StmtWhile: ast::Stmt = {
  "while" <cond:Expr> "{" <body:Stmt*> "}" => ast::Stmt::While { cond, body },
}

pub StmtVarDefFor: ast::Stmt = {
  <name:"id"> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: None, value, mutable: true }
  },
}

pub StmtFor: ast::Stmt = {
  "for" <init:StmtVarDefFor?> ";" <cond:Expr?> ";" <step:StmtVarAssign?> "{" <body:Stmt*> "}" => {
    ast::Stmt::For { init: init.map(Box::new), cond, step: step.map(Box::new), body }
  },
}

pub StmtReturn: ast::Stmt = {
  "return" <value:Expr> => ast::Stmt::Return { value: Some(value) }
}

pub StmtFnDef: ast::Stmt = {
  "fn" <name:"id"> "(" <params:ParamList?> ")" "->" <ret:BasicType> "{" <body:Stmt*> "}" => {
    ast::Stmt::FnDef {
        name,
        params: params.unwrap_or_default(),
        ret_type: ret,
        body,
    }
  },
}

pub StmtFnCall: ast::Stmt = {
  <name:"id"> "(" <args:ExprList?> ")" => {
    ast::Stmt::FnCall { name, args: args.unwrap_or_default() }
  },
}

pub ExprValue: ast::Expr = {
  <e:Expr> => *e,
}

pub ExprList: Vec<ast::Expr> = {
  <first:ExprValue> <rest:("," <ExprValue>)*> => {
    let mut v = vec![first];
    v.extend(rest);
    v
  }
}

pub ParamList: Vec<(String, Type)> = {
  <first:Param> <rest:("," <Param>)*> => {
    let mut v = vec![first];
    v.extend(rest);
    v
  }
}

pub Param: (String, Type) = {
  <name:"id"> ":" <ty:ParamType> => (name, ty)
}

pub ParamType: Type = {
  BasicType,
  "FixedArray" "[" <elem:BasicType>"]" => {
    Type::FixedArray(Box::new(elem), None)
  },
}

pub StmtVarDef: ast::Stmt = {
  "let" <name:"id"> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: None, value, mutable: false }
  },
  "let" "mut" <name:"id"> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: None, value, mutable: true }
  },
  "let" <name:"id"> ":" <annot:BasicType> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: Some(annot), value, mutable: false }
  },
  "let" "mut" <name:"id"> ":" <annot:BasicType> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: Some(annot), value, mutable: true }
  },
}

pub StmtFixedArrayDef: ast::Stmt = {
  "let" <name:"id"> ":" "FixedArray" "[" <elem:BasicType> "]" "=" "[" <values:ExprList?> "]" => {
    let vs: Vec<ast::Expr> = values.unwrap_or_default();
    let n = vs.len();
    ast::Stmt::FixedArrayDef { name, annot: Type::FixedArray(Box::new(elem), Some(n)), values: vs, mutable: false }
  },
  "let" "mut" <name:"id"> ":" "FixedArray" "[" <elem:BasicType> "]" "=" "[" <values:ExprList?> "]" => {
    let vs: Vec<ast::Expr> = values.unwrap_or_default();
    let n = vs.len();
    ast::Stmt::FixedArrayDef { name, annot: Type::FixedArray(Box::new(elem), Some(n)), values: vs, mutable: true }
  },
}

pub StmtGlobalVarDef: ast::Stmt = {
  "let" <name:"id"> "=" <value:BasicTerm>  => {
    ast::Stmt::GlobalVarDef { name, annot: None, value, is_const: false }
  },
  "let" <name:"id"> ":" <annot:BasicType> "=" <value:BasicTerm>  => {
    ast::Stmt::GlobalVarDef { name, annot: Some(annot), value, is_const: false }
  },
  "const" <name:"id"> "=" <value:BasicTerm>  => {
    ast::Stmt::GlobalVarDef { name, annot: None, value, is_const: true }
  },
  "const" <name:"id"> ":" <annot:BasicType> "=" <value:BasicTerm>  => {
    ast::Stmt::GlobalVarDef { name, annot: Some(annot), value, is_const: true }
  },
}

pub StmtVarAssign: ast::Stmt = {
  <name:"id"> "=" <value:Expr> => {
    ast::Stmt::VarAssign { name, value }
  },
}

pub BasicType: Type = {
  "Int" => Type::Int,
  "Double" => Type::Double,
  "Unit" => Type::Unit,
  "Bool" => Type::Bool,
}

pub StmtPrint: ast::Stmt = {
  "println" "(" <value:Expr> ")"  => {
    ast::Stmt::PrintExpr { value }
  },
  "println" "(" <value:"string"> ")"  => {
    ast::Stmt::PrintString { value }
  },
}

pub Term: Box<ast::Expr> = {
  <value:"int"> => {
    Box::new(ast::Expr::Int(value))
  },
  <value:"double"> => {
    Box::new(ast::Expr::Double(value))
  },
  "true" => Box::new(ast::Expr::Bool(true)),
  "false" => Box::new(ast::Expr::Bool(false)),
  <name:"id"> "(" <args:ExprList?> ")" => {
    let args: Vec<ast::Expr> = args.unwrap_or_default();
    Box::new(ast::Expr::Call { name, args })
  },
  <name:"id"> "[" <index:Expr> "]" => {
    Box::new(ast::Expr::Index { name, index })
  },
  <name:"id"> => {
    Box::new(ast::Expr::Var(name))
  },
  "(" <Expr> ")",
}

pub BasicTerm: Box<ast::Expr> = {
  <value:"int"> => {
    Box::new(ast::Expr::Int(value))
  },
  <value:"double"> => {
    Box::new(ast::Expr::Double(value))
  },
  "true" => Box::new(ast::Expr::Bool(true)),
  "false" => Box::new(ast::Expr::Bool(false)),
}

pub Expr: Box<ast::Expr> = {
  #[precedence(level="1")]
  Term,

  #[precedence(level="2")] #[assoc(side="left")]
  <lhs:Expr> "*" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Mul, rhs }),
  <lhs:Expr> "/" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Div, rhs }),

  #[precedence(level="3")] #[assoc(side="left")]
  <lhs:Expr> "+" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Add, rhs }),
  <lhs:Expr> "-" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Sub, rhs }),

  #[precedence(level="4")] #[assoc(side="left")]
  <lhs:Expr> "<" <rhs:Expr>  => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Lt, rhs }),
  <lhs:Expr> ">" <rhs:Expr>  => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Gt, rhs }),
  <lhs:Expr> "<=" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Le, rhs }),
  <lhs:Expr> ">=" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Ge, rhs }),

  #[precedence(level="5")] #[assoc(side="left")]
  <lhs:Expr> "==" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Eq, rhs }),
  <lhs:Expr> "!=" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Ne, rhs }),

  #[precedence(level="6")] #[assoc(side="left")]
  <lhs:Expr> "&&" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::And, rhs }),
  <lhs:Expr> "||" <rhs:Expr> => Box::new(ast::Expr::BinaryOp { lhs, operator: ast::Op::Or, rhs }),
}


extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "id" => Token::Id(<String>),
        "int" => Token::Int(<i32>),
        "double" => Token::Double(<f64>),
        "string" => Token::String(<String>),
        "fn" => Token::Fn,
        "return" => Token::Return,
        "println" => Token::Println,
        "let" => Token::Let,
        "const" => Token::Const,
        "mut" => Token::Mut,
        "while" => Token::While,
        "for" => Token::For,
        "if" => Token::If,
        "else" => Token::Else,
        "main" => Token::Main,
        "Int" => Token::IntType,
        "Double" => Token::DoubleType,
        "Unit" => Token::UnitType,
        "Bool" => Token::BoolType,
        "FixedArray" => Token::FixedArrayType,
        "true" => Token::True,
        "false" => Token::False,
        "==" => Token::Eq,
        "!=" => Token::Neq,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "&&" => Token::And,
        "||" => Token::Or,
        "->" => Token::Arrow,
        "::" => Token::DoubleColon,
        "=>" => Token::FatArrow,
        "=" => Token::Assign,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "!" => Token::Not,
        ":" => Token::Col,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "." => Token::Dot,
        "@" => Token::At,
    }
}
