use crate::tokens::{Token, LexicalError};
use crate::ast;
use crate::types::Type;

grammar;

pub Script: Vec<ast::Stmt> = {
  <stmts:Stmt*> => stmts
}

pub Stmt: ast::Stmt = {
  StmtMainDef,
  StmtVarDef,
  StmtVarAssign,
  StmtPrint,
  StmtFnDef,
  StmtFnCall,
  StmtReturn,
}

pub StmtMainDef: ast::Stmt = {
  "fn" "main" "{" <body:Stmt*> "}" => {
    ast::Stmt::MainDef {
        body,
    }
  },
}

pub StmtReturn: ast::Stmt = {
  "return" <value:Expr> => ast::Stmt::Return { value: Some(value) }
}

pub StmtFnDef: ast::Stmt = {
  "fn" <name:"id"> "(" <params:ParamList?> ")" "->" <ret:Type> "{" <body:Stmt*> "}" => {
    ast::Stmt::FnDef {
        name,
        params: params.unwrap_or_default(),
        ret_type: ret,
        body,
    }
  },
}

pub StmtFnCall: ast::Stmt = {
  <name:"id"> "(" <args:ExprList?> ")" => {
    ast::Stmt::FnCall {
        name,
        args: args.unwrap_or_default(),
    }
  },
}

pub ExprList: Vec<Box<ast::Expr>> = {
  <first:Expr> <rest:("," <Expr>)*> => {
    let mut v = vec![first];
    v.extend(rest);
    v
  }
}

pub ParamList: Vec<(String, Type)> = {
  <first:Param> <rest:("," <Param>)*> => {
    let mut v = vec![first];
    v.extend(rest);
    v
  }
}

pub Param: (String, Type) = {
  <name:"id"> ":" <ty:Type> => (name, ty)
}

pub StmtVarDef: ast::Stmt = {
  "let" <name:"id"> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: None, value, mutable: false }
  },
  "let" "mut" <name:"id"> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: None, value, mutable: true }
  },
  "let" <name:"id"> ":" <annot:Type> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: Some(annot), value, mutable: false }
  },
  "let" "mut" <name:"id"> ":" <annot:Type> "=" <value:Expr>  => {
    ast::Stmt::VarDef { name, annot: Some(annot), value, mutable: true }
  },
}

pub StmtVarAssign: ast::Stmt = {
  <name:"id"> "=" <value:Expr> => {
    ast::Stmt::VarAssign { name, value }
  },
}

pub Type: Type = {
  "Int" => Type::Int,
  "Double" => Type::Double,
  "Unit" => Type::Unit,
}

pub StmtPrint: ast::Stmt = {
  "println" "(" <value:Expr> ")"  => {
    ast::Stmt::PrintExpr { value }
  },
  "println" "(" <value:"string"> ")"  => {
    ast::Stmt::PrintString { value }
  },
}

pub Expr: Box<ast::Expr> = {
  #[precedence(level="1")]
  Term,

  #[precedence(level="2")] #[assoc(side="left")]
  <lhs:Expr> "*" <rhs:Expr> => {
    Box::new(ast::Expr::BinaryOp {
      lhs,
      operator: ast::Op::Mul,
      rhs
    })
  },
  <lhs:Expr> "/" <rhs:Expr> => {
    Box::new(ast::Expr::BinaryOp {
      lhs,
      operator: ast::Op ::Div,
      rhs
    })
  },

  #[precedence(level="3")] #[assoc(side="left")]
  <lhs:Expr> "+" <rhs:Expr> => {
    Box::new(ast::Expr::BinaryOp {
      lhs,
      operator: ast::Op::Add,
      rhs
    })
  },
  <lhs:Expr> "-" <rhs:Expr> => {
    Box::new(ast::Expr::BinaryOp {
      lhs,
      operator: ast::Op::Sub,
      rhs
    })
  },
}

pub Term: Box<ast::Expr> = {
  <value:"int"> => {
    Box::new(ast::Expr::Int(value))
  },
  <value:"double"> => {
    Box::new(ast::Expr::Double(value))
  },
  <name:"id"> "(" <args:ExprList?> ")" => {
    let args: Vec<Box<ast::Expr>> = args
      .unwrap_or_default();
    Box::new(ast::Expr::Call { name, args })
  },
  <name:"id"> => {
    Box::new(ast::Expr::Var(name))
  },
  "(" <Expr> ")",
}


extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "id" => Token::Id(<String>),
        "int" => Token::Int(<i32>),
        "double" => Token::Double(<f64>),
        "string" => Token::String(<String>),
        "fn" => Token::Fn,
        "return" => Token::Return,
        "println" => Token::Println,
        "let" => Token::Let,
        "const" => Token::Const,
        "mut" => Token::Mut,
        "while" => Token::While,
        "for" => Token::For,
        "if" => Token::If,
        "else" => Token::Else,
        "main" => Token::Main,
        "Int" => Token::IntType,
        "Double" => Token::DoubleType,
        "Unit" => Token::UnitType,
        "==" => Token::Eq,
        "!=" => Token::Neq,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "&&" => Token::And,
        "||" => Token::Or,
        "->" => Token::Arrow,
        "::" => Token::DoubleColon,
        "=>" => Token::FatArrow,
        "=" => Token::Assign,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "!" => Token::Not,
        ":" => Token::Col,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "." => Token::Dot,
        "@" => Token::At,
    }
}
